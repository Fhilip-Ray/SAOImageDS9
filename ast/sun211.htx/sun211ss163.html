<!DOCTYPE html> 
<html> 
<head><title> astRebinSeq&#x003C;X&#x003E; </title> 
<meta charset=utf-8/> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<link rel="stylesheet" type="text/css" href="sun211.css" /> 
 <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML"></script><style type="text/css">.MathJax_MathML {text-indent: 0;}</style></head><body 
>
<div class="sstrefsection"><div class="crosslinks"><ul class='nav'> <li class="prev"> <a 
href="sun211ss162.html" >&#8592Prev</a>&#x00A0;</li> <li class="title">AST<BR>A Library for Handling<BR>World Coordinate Systems<BR>in Astronomy</li> <li class="next"><a 
href="sun211ss164.html" >Next&#8594</a>&#x00A0;</li> <li class="toc"><a 
href="sun211.html#toc">TOC &#8593</a></li>
</ul></div>
<!--l. 26130--><p class="noindent" ><header class="sstreftitle"><h3 class="sstsectitle"><a 
 id="x188-3800000"></a> astRebinSeq<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
</h3>  <p class="subtitle"> Rebin a region of a sequence of data grids  </p> </h3> </header><a 
 id="Q1-188-722"></a> <a 
 id="Q1-188-723"></a> <a name="xref_astRebinSeq$<$X$>$"></a>  <h4 class="ssth4">Description: </h4><div class="sstvalues"> This set of functions is identical to
<a 
href="sun211ss162.html#x187-3790000">astRebin<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></a>
except that the rebinned input data is added into the supplied output arrays, rather
than simply over-writing the contents of the output arrays. Thus, by calling this
function repeatedly, a sequence of input arrays can be rebinned and accumulated
into a single output array, effectively forming a mosaic of the input data
arrays.
<!--l. 26130--><p class="noindent" >In addition, the weights associated with each output pixel are returned. The weight of
an output pixel indicates the number of input pixels which have been accumulated
in that output pixel. If the entire value of an input pixel is assigned to a
single output pixel, then the weight of that output pixel is incremented by
one. If some fraction of the value of an input pixel is assigned to an output
pixel, then the weight of that output pixel is incremented by the fraction
used.
<!--l. 26130--><p class="noindent" >The start of a new sequence is indicated by specifying the AST__REBININIT flag via the
<code>&#x0022;</code> flags<code>&#x0022;</code> parameter. This causes the supplied arrays to be filled with zeros before the
rebinned input data is added into them. Subsequenct invocations within the same
sequence should omit the AST__REBININIT flag.
<!--l. 26130--><p class="noindent" >The last call in a sequence is indicated by specifying the AST__REBINEND flag.
Depending on which flags are supplied, this may cause the output data and variance
arrays to be normalised before being returned. This normalisation consists of dividing
the data array by the weights array, and can eliminate artifacts which may be
introduced into the rebinned data as a consequence of aliasing between the input and
output grids. This results in each output pixel value being the weighted mean of the
input pixel values that fall in the neighbourhood of the output pixel (rather like
<a 
href="sun211ss172.html#x197-3890000">astResample<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></a>).
Optionally, these normalised values can then be multiplied by a scaling factor to
                                                                                       

                                                                                       
ensure that the total data sum in any small area is unchanged. This scaling factor is
equivalent to the number of input pixel values that fall into each output pixel. In
addition to normalisation of the output data values, any output variances are also
appropriately normalised, and any output data values with weight less than <code>&#x0022;</code> wlim<code>&#x0022;</code> are
set to <code>&#x0022;</code> badval<code>&#x0022;</code> .
<!--l. 26130--><p class="noindent" >Output variances can be generated in two ways; by rebinning the supplied input variances
with appropriate weights, or by finding the spread of input data values contributing to
each output pixel (see the AST__GENVAR and AST__USEVAR flags).  </div> <h4 class="ssth4">Synopsis </h4><div class="sstvalues"> void
astRebinSeq<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>(
AstMapping <!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">&#x2217;</mo></math>this,
double wlim, int ndim_in, const int lbnd_in[], const int ubnd_in[], const
<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Xtype<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
in[], const <!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Xtype<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
in_var[], int spread, const double params[], int flags, double tol, int maxpix,
<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Xtype<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
badval, int ndim_out, const int lbnd_out[], const int ubnd_out[], const int lbnd[], const int ubnd[],
<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Xtype<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
out[], <!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Xtype<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
out_var[], double weights[], int64_t
<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">&#x2217;</mo></math>nused
);  </div> <h4 class="ssth4">Parameters: </h4><div class="sstvalues"> <h5 class="ssth5"> this  </h5><div class="sstsub"> Pointer to a <a 
href="sun211ss459.html#x486-6780000">Mapping</a>, whose forward transformation will be
used to transform the coordinates of pixels in the input grid into the coordinate
system of the output grid.
<!--l. 26130--><p class="noindent" >The number of input coordinates used by this Mapping (as given by its <a 
href="sun211ss353.html#x379-5710000">Nin</a> attribute)
should match the number of input grid dimensions given by the value of <code>&#x0022;</code> ndim_in<code>&#x0022;</code>
below. Similarly, the number of output coordinates (<a 
href="sun211ss359.html#x385-5770000">Nout</a> attribute) should match
the number of output grid dimensions given by <code>&#x0022;</code> ndim_out<code>&#x0022;</code> . If <code>&#x0022;</code> in<code>&#x0022;</code> is NULL,
the Mapping will not be used, but a valid Mapping must still be supplied.  </div> <h5 class="ssth5">
wlim  </h5><div class="sstsub"> This value is only used if the AST__REBINEND flag is specified via the <code>&#x0022;</code>
flags<code>&#x0022;</code> parameter. It gives the required number of input pixel values which
must contribute to an output pixel (i.e. the output pixel weight) in order
for the output pixel value to be considered valid. If the sum of the input
pixel weights contributing to an output pixel is less than the supplied <code>&#x0022;</code> wlim<code>&#x0022;</code>
value, then the output pixel value is returned set to the supplied bad value.
If the supplied value is less than 1.0E-10 then 1.0E-10 is used instead.  </div> <h5 class="ssth5">
ndim_in  </h5><div class="sstsub"> The number of dimensions in the input grid. This should be at least one.
Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is NULL.  </div> <h5 class="ssth5"> lbnd_in  </h5><div class="sstsub"> Pointer to an array of integers, with
<code>&#x0022;</code> ndim_in<code>&#x0022;</code> elements, containing the coordinates of the centre of the first
pixel in the input grid along each dimension. Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is NULL.  </div> <h5 class="ssth5">
ubnd_in  </h5><div class="sstsub"> Pointer to an array of integers, with <code>&#x0022;</code> ndim_in<code>&#x0022;</code> elements, containing
the coordinates of the centre of the last pixel in the input grid along each
dimension.
<!--l. 26130--><p class="noindent" >Note that <code>&#x0022;</code> lbnd_in<code>&#x0022;</code> and <code>&#x0022;</code> ubnd_in<code>&#x0022;</code> together define the shape and size of
the input grid, its extent along a particular (j<code>&#x2019;</code> th) dimension being
ubnd_in[j]-lbnd_in[j]<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>1
(assuming the index <code>&#x0022;</code> j<code>&#x0022;</code> to be zero-based). They also define the input grid<code>&#x2019;</code> s
coordinate system, each pixel having unit extent along each dimension with integral
                                                                                       

                                                                                       
coordinate values at its centre. Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is NULL.  </div> <h5 class="ssth5"> in  </h5><div class="sstsub"> Pointer to an
array, with one element for each pixel in the input grid, containing the input data to
be rebined. The numerical type of this array should match the 1- or 2-character type
code appended to the function name (e.g. if you are using astRebinSeqF, the type of
each array element should be <code>&#x0022;</code> float<code>&#x0022;</code> ).
<!--l. 26130--><p class="noindent" >The storage order of data within this array should be such that the index of the first
grid dimension varies most rapidly and that of the final dimension least rapidly (i.e.
Fortran array indexing is used). If a NULL pointer is supplied for <code>&#x0022;</code> in<code>&#x0022;</code> , then no
data is added to the output arrays, but any initialisation or normalisation
requested by <code>&#x0022;</code> flags<code>&#x0022;</code> is still performed.  </div> <h5 class="ssth5"> in_var  </h5><div class="sstsub"> An optional pointer to a
second array with the same size and type as the <code>&#x0022;</code> in<code>&#x0022;</code> array. If given, this
should contain a set of non-negative values which represent estimates of the
statistical variance associated with each element of the <code>&#x0022;</code> in<code>&#x0022;</code> array. If neither the
AST__USEVAR nor the AST__VARWGT flag is set, no input variance estimates are
required and this pointer will not be used. A NULL pointer may then be supplied.  </div>
<h5 class="ssth5"> spread  </h5><div class="sstsub"> This parameter specifies the scheme to be used for dividing each
input data value up amongst the corresponding output pixels. It may be used
to select from a set of pre-defined schemes by supplying one of the values
described in the <code>&#x0022;</code> Pixel Spreading Schemes<code>&#x0022;</code> section in the description of the
astRebin<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
functions. If a value of zero is supplied, then the default linear spreading scheme is
used (equivalent to supplying the value AST__LINEAR). Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is NULL.  </div> <h5 class="ssth5">
params  </h5><div class="sstsub"> An optional pointer to an array of double which should contain any additional
parameter values required by the pixel spreading scheme. If such parameters are required,
this will be noted in the <code>&#x0022;</code> Pixel Spreading Schemes<code>&#x0022;</code> section in the description of the
astRebin<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
functions.
<!--l. 26130--><p class="noindent" >If no additional parameters are required, this array is not used and a NULL pointer may
be given. Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is NULL.  </div> <h5 class="ssth5"> flags  </h5><div class="sstsub"> The bitwise OR of a set of flag values
which may be used to provide additional control over the rebinning operation. See the <code>&#x0022;</code>
Control Flags<code>&#x0022;</code> section below for a description of the options available. If
no flag values are to be set, a value of zero should be given.  </div> <h5 class="ssth5"> tol  </h5><div class="sstsub"> The
maximum tolerable geometrical distortion which may be introduced as a result of
approximating non-linear Mappings by a set of piece-wise linear transformations. This
should be expressed as a displacement in pixels in the output grid<code>&#x2019;</code> s coordinate
system.
<!--l. 26130--><p class="noindent" >If piece-wise linear approximation is not required, a value of zero may be given. This
will ensure that the Mapping is used without any approximation, but may increase
execution time.
<!--l. 26130--><p class="noindent" >If the value is too high, discontinuities between the linear approximations used in
adjacent panel will be higher, and may cause the edges of the panel to be visible when
viewing the output image at high contrast. If this is a problem, reduce the tolerance
value used. Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is NULL.  </div> <h5 class="ssth5"> maxpix  </h5><div class="sstsub"> A value which specifies an initial
scale size (in pixels) for the adaptive algorithm which approximates non-linear
Mappings with piece-wise linear transformations. Normally, this should be a large value
(larger than any dimension of the region of the input grid being used). In this case, a
first attempt to approximate the Mapping by a linear transformation will be made over
                                                                                       

                                                                                       
the entire input region.
<!--l. 26130--><p class="noindent" >If a smaller value is used, the input region will first be divided into sub-regions
whose size does not exceed <code>&#x0022;</code> maxpix<code>&#x0022;</code> pixels in any dimension. Only at this point will
attempts at approximation commence.
<!--l. 26130--><p class="noindent" >This value may occasionally be useful in preventing false convergence of the adaptive
algorithm in cases where the Mapping appears approximately linear on large scales, but
has irregularities (e.g. holes) on smaller scales. A value of, say, 50 to 100 pixels
can also be employed as a safeguard in general-purpose software, since the effect on
performance is minimal.
<!--l. 26130--><p class="noindent" >If too small a value is given, it will have the effect of inhibiting linear
approximation altogether (equivalent to setting <code>&#x0022;</code> tol<code>&#x0022;</code> to zero). Although this may
degrade performance, accurate results will still be obtained. Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is
NULL.  </div> <h5 class="ssth5"> badval  </h5><div class="sstsub"> This argument should have the same type as the elements of the <code>&#x0022;</code> in<code>&#x0022;</code>
array. It specifies the value used to flag missing data (bad pixels) in the input and
output arrays.
<!--l. 26130--><p class="noindent" >If the AST__USEBAD flag is set via the <code>&#x0022;</code> flags<code>&#x0022;</code> parameter, then this value is used to
test for bad pixels in the <code>&#x0022;</code> in<code>&#x0022;</code> (and <code>&#x0022;</code> in_var<code>&#x0022;</code> ) array(s).
<!--l. 26130--><p class="noindent" >In all cases, this value is also used to flag any output elements in the <code>&#x0022;</code> out<code>&#x0022;</code> (and <code>&#x0022;</code>
out_var<code>&#x0022;</code> ) array(s) for which rebined values could not be obtained (see the <code>&#x0022;</code>
Propagation of Missing Data<code>&#x0022;</code> section below for details of the circumstances under which
this may occur).  </div> <h5 class="ssth5"> ndim_out  </h5><div class="sstsub"> The number of dimensions in the output grid. This should
be at least one. It need not necessarily be equal to the number of dimensions in the
input grid.  </div> <h5 class="ssth5"> lbnd_out  </h5><div class="sstsub"> Pointer to an array of integers, with <code>&#x0022;</code> ndim_out<code>&#x0022;</code> elements,
containing the coordinates of the centre of the first pixel in the output grid along
each dimension.  </div> <h5 class="ssth5"> ubnd_out  </h5><div class="sstsub"> Pointer to an array of integers, with <code>&#x0022;</code> ndim_out<code>&#x0022;</code>
elements, containing the coordinates of the centre of the last pixel in the output grid
along each dimension.
<!--l. 26130--><p class="noindent" >Note that <code>&#x0022;</code> lbnd_out<code>&#x0022;</code> and <code>&#x0022;</code> ubnd_out<code>&#x0022;</code> together define the shape, size and coordinate
system of the output grid in the same way as <code>&#x0022;</code> lbnd_in<code>&#x0022;</code> and <code>&#x0022;</code> ubnd_in<code>&#x0022;</code> define the
shape, size and coordinate system of the input grid.  </div> <h5 class="ssth5"> lbnd  </h5><div class="sstsub"> Pointer to an
array of integers, with <code>&#x0022;</code> ndim_in<code>&#x0022;</code> elements, containing the coordinates of the
first pixel in the region of the input grid which is to be included in the
rebined output array. Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is NULL.  </div> <h5 class="ssth5"> ubnd  </h5><div class="sstsub"> Pointer to an array of
integers, with <code>&#x0022;</code> ndim_in<code>&#x0022;</code> elements, containing the coordinates of the last pixel in
the region of the input grid which is to be included in the rebined output
array.
<!--l. 26130--><p class="noindent" >Note that <code>&#x0022;</code> lbnd<code>&#x0022;</code> and <code>&#x0022;</code> ubnd<code>&#x0022;</code> together define the shape and position of a
(hyper-)rectangular region of the input grid which is to be included in the
rebined output array. This region should lie wholly within the extent of the
input grid (as defined by the <code>&#x0022;</code> lbnd_in<code>&#x0022;</code> and <code>&#x0022;</code> ubnd_in<code>&#x0022;</code> arrays). Regions of the
input grid lying outside this region will not be used. Not used if <code>&#x0022;</code> in<code>&#x0022;</code> is
NULL.  </div> <h5 class="ssth5"> out  </h5><div class="sstsub"> Pointer to an array, with one element for each pixel in the
output grid. The rebined data values will be added into the original contents
of this array. The numerical type of this array should match that of the <code>&#x0022;</code>
in<code>&#x0022;</code> array, and the data storage order should be such that the index of the
                                                                                       

                                                                                       
first grid dimension varies most rapidly and that of the final dimension least
rapidly (i.e. Fortran array indexing is used).  </div> <h5 class="ssth5"> out_var  </h5><div class="sstsub"> A pointer to an
array with the same type and size as the <code>&#x0022;</code> out<code>&#x0022;</code> array. This pointer will only
be used if the AST__USEVAR or AST__GENVAR flag is set in which case variance
estimates for the rebined data values will be added into the array. If neither the
AST__USEVAR flag nor the AST__GENVAR flag is set, no output variance estimates will
be calculated and this pointer will not be used. A NULL pointer may then be
supplied.  </div> <h5 class="ssth5"> weights  </h5><div class="sstsub"> Pointer to an array of double, with one or two elements for
each pixel in the output grid, depending on whether or not the AST__GENVAR
flag has been supplied via the <code>&#x0022;</code> flags<code>&#x0022;</code> parameter. If AST__GENVAR has not been
specified then the array should have one element for each output pixel, and it
will be used to accumulate the weight associated with each output pixel. If
AST__GENVAR has been specified then the array should have two elements for
each output pixel. The first half of the array is again used to accumulate
the weight associated with each output pixel, and the second half is used to
accumulate the square of the weights. In each half, the data storage order
should be such that the index of the first grid dimension varies most rapidly
and that of the final dimension least rapidly (i.e. Fortran array indexing
is used).  </div> <h5 class="ssth5"> nused  </h5><div class="sstsub"> A pointer to an int64_t containing the number of input
data values that have been added into the output array so far. The supplied
value is incremented on exit by the number of input values used. The value is
initially set to zero if the AST__REBININIT flag is set in <code>&#x0022;</code> flags<code>&#x0022;</code> .  </div>  </div> <h4 class="ssth4"> Data
Type Codes  </h4><div class="sstvalues"> To select the appropriate rebinning function, you should replace
<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
in the generic function name astRebinSeq<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
with a 1- or 2-character data type code, so as to match the numerical type
<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Xtype<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
of the data you are processing, as follows: <ul class="sstitemlist">
<li >
<!--l. 26130--><p class="noindent" >D: double
<li >
<!--l. 26130--><p class="noindent" >F: float
<li >
<!--l. 26130--><p class="noindent" >I: int
<li >
<!--l. 26130--><p class="noindent" >B: byte (signed char)
<li >
<!--l. 26130--><p class="noindent" >UB: unsigned byte (unsigned char)
</li>
</ul>
<!--l. 26130--><p class="noindent" >For example, astRebinSeqD would be used to process <code>&#x0022;</code> double<code>&#x0022;</code> data, while astRebinSeqI
would be used to process <code>&#x0022;</code> int<code>&#x0022;</code> data, etc.
<!--l. 26130--><p class="noindent" >Note that, unlike astResample<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>,
the astRebinSeq<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
set of functions does not yet support unsigned integer data types or integers of
                                                                                       

                                                                                       
different sizes.  </div> <h4 class="ssth4"> Control Flags  </h4><div class="sstvalues"> The following flags are defined in the <code>&#x0022;</code> ast.h<code>&#x0022;</code>
header file and may be used to provide additional control over the rebinning process.
Having selected a set of flags, you should supply the bitwise OR of their values via
the <code>&#x0022;</code> flags<code>&#x0022;</code> parameter:
<ul class="sstitemlist">
<li >
<!--l. 26130--><p class="noindent" >AST__REBININIT: Used to mark the first call in a sequence. It indicates that the
supplied <code>&#x0022;</code> out<code>&#x0022;</code> , <code>&#x0022;</code> out_var<code>&#x0022;</code> and <code>&#x0022;</code> weights<code>&#x0022;</code> arrays should be filled with zeros
(thus over-writing any supplied values) before adding the rebinned input data
into them. This flag should be used when rebinning the first input array in a
sequence.
<li >
<!--l. 26130--><p class="noindent" >AST__REBINEND: Used to mark the last call in a sequence. It causes each value in the <code>&#x0022;</code>
out<code>&#x0022;</code> and <code>&#x0022;</code> out_var<code>&#x0022;</code> arrays to be divided by a normalisation factor before being
returned. The normalisation factor for each output data value is just the corresponding
value from the weights array. The normalisation factor for each output variance value
is the square of the data value normalisation factor (see also AST__CONSERVEFLUX). It
also causes output data values to be set bad if the corresponding weight is less than
the value supplied for parameter <code>&#x0022;</code> wlim<code>&#x0022;</code> . It also causes any temporary values stored
in the output variance array (see flag AST__GENVAR below) to be converted into
usable variance values. Note, this flag is ignored if the AST__NONORM flag is
set.
<li >
<!--l. 26130--><p class="noindent" >AST__USEBAD: Indicates that there may be bad pixels in the input array(s) which must be
recognised by comparing with the value given for <code>&#x0022;</code> badval<code>&#x0022;</code> and propagated to the output
array(s). If this flag is not set, all input values are treated literally and the <code>&#x0022;</code>
badval<code>&#x0022;</code> value is only used for flagging output array values.
<li >
<!--l. 26130--><p class="noindent" >AST__USEVAR: Indicates that output variance estimates should be created by rebinning
the supplied input variance estimates. An error will be reported if both this flag and
the AST__GENVAR flag are supplied.
<li >
<!--l. 26130--><p class="noindent" >AST__GENVAR: Indicates that output variance estimates should be created based on the
spread of input data values contributing to each output pixel. An error will
be reported if both this flag and the AST__USEVAR flag are supplied. If the
AST__GENVAR flag is specified, the supplied output variance array is first
used as a work array to accumulate the temporary values needed to generate the
output variances. When the sequence ends (as indicated by the AST__REBINEND
flag), the contents of the output variance array are converted into the required
variance estimates. If the generation of such output variances is required, this
flag should be used on every invocation of this function within a sequence,
and any supplied input variances will have no effect on the output variances
(although input variances will still be used to weight the input data if the
AST__VARWGT flag is also supplied). The statistical meaning of these output
varianes is determined by the presence or absence of the AST__DISVAR flag (see
below).
                                                                                       

                                                                                       
<li >
<!--l. 26130--><p class="noindent" >AST__DISVAR: This flag is ignored unless the AST__GENVAR flag has also been specified.
It determines the statistical meaning of the generated output variances. If AST__DISVAR
is not specified, generated variances represent variances on the output mean values. If
AST__DISVAR is specified, the generated variances represent the variance of
the distribution from which the input values were taken. Each output variance
created with AST__DISVAR will be larger than that created without AST__DISVAR by
a factor equal to the number of input samples that contribute to the output
sample.
<li >
<!--l. 26130--><p class="noindent" >AST__VARWGT: Indicates that the input data should be weighted by the reciprocal
of the input variances. Otherwise, all input data are given equal weight. If
this flag is specified, the calculation of the output variances (if any) is
modified to take account of the varying weights assigned to the input data
values.
<li >
<!--l. 26130--><p class="noindent" >AST__NONORM: If the simple unnormalised sum of all input data falling in each output
pixel is required, then this flag should be set on each call in the sequence and the
AST__REBINEND should not be used on the last call. In this case NULL pointers can
be supplied for <code>&#x0022;</code> weights<code>&#x0022;</code> and <code>&#x0022;</code> nused<code>&#x0022;</code> . This flag cannot be used with the
AST__CONSERVEFLUX, AST__GENVAR or AST__VARWGT flag.
<li >
<!--l. 26130--><p class="noindent" >AST__CONSERVEFLUX: Indicates that the normalized output pixel values generated by the
AST__REBINEND flag should be scaled in such a way as to preserve the total data value
in a feature on the sky. Without this flag, each normalised output pixel value
represents a weighted mean of the input data values around the corresponding input
position. is appropriate if the input data represents the spatial density of some
quantity (e.g. surface brightness in Janskys per square arc-second) because the output
pixel values will have the same normalisation and units as the input pixel values.
However, if the input data values represent flux (or some other physical quantity) per
pixel, then the AST__CONSERVEFLUX flag could be of use. It causes each output pixel
value to be scaled by the ratio of the output pixel size to the input pixel
size.
</li>
</ul>
<!--l. 26130--><p class="noindent" >This flag can only be used if the Mapping is successfully approximated by one or more
linear transformations. Thus an error will be reported if it used when the <code>&#x0022;</code> tol<code>&#x0022;</code>
parameter is set to zero (which stops the use of linear approximations), or if the
Mapping is too non-linear to be approximated by a piece-wise linear transformation. The
ratio of output to input pixel size is evaluated once for each panel of the piece-wise
linear approximation to the Mapping, and is assumed to be constant for all output
pixels in the panel. The scaling factors for adjacent panels will in general differ
slightly, and so the joints between panels may be visible when viewing the output
image at high contrast. If this is a problem, reduce the value of the <code>&#x0022;</code> tol<code>&#x0022;</code>
parameter until the difference between adjacent panels is sufficiently small to be
insignificant.
                                                                                       

                                                                                       
<!--l. 26130--><p class="noindent" >This flag should normally be supplied on each invocation of
astRebinSeq<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>X<!--l. 26130--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>
within a given sequence.
<!--l. 26130--><p class="noindent" >Note, this flag cannot be used in conjunction with the AST__NOSCALE flag (an error will
be reported if both flags are specified).  </div> <h4 class="ssth4"> Propagation of Missing Data  </h4><div class="sstvalues"> Instances of
missing data (bad pixels) in the output grid are identified by occurrences of the <code>&#x0022;</code>
badval<code>&#x0022;</code> value in the <code>&#x0022;</code> out<code>&#x0022;</code> array. These are only produced if the AST__REBINEND flag is
specified and a pixel has zero weight.
<!--l. 26130--><p class="noindent" >An input pixel is considered bad (and is consequently ignored) if its data
value is equal to <code>&#x0022;</code> badval<code>&#x0022;</code> and the AST__USEBAD flag is set via the <code>&#x0022;</code> flags<code>&#x0022;</code>
parameter.
<!--l. 26130--><p class="noindent" >In addition, associated output variance estimates (if calculated) may be declared bad
and flagged with the <code>&#x0022;</code> badval<code>&#x0022;</code> value in the <code>&#x0022;</code> out_var<code>&#x0022;</code> array for similar reasons.
</div><div class="crosslinks"> <div class="copyright"><span class="pushright">Copyright (C) 2014 Science &#x0026; Technology Facilities Council</span></div> <ul class='nav'> <li class="prev"> <a 
href="sun211ss162.html" >&#8592Prev</a>&#x00A0;</li> <li class="title">AST<BR>A Library for
Handling<BR>World Coordinate Systems<BR>in Astronomy</li> <li class="next"><a 
href="sun211ss164.html" >Next&#8594</a>&#x00A0;</li> <li class="toc"><a 
href="sun211.html#toc">TOC &#8593</a></li> </ul></div>
<!--l. 33670--><p class="noindent" ><a 
 id="tailsun211ss163.html"></a> </div> 
</body> 
</html>