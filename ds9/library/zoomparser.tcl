
######
# Begin autogenerated taccle (version 1.2) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval zoom {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0

    namespace export yylex
}

proc zoom::YYABORT {} {
    return -code return 1
}

proc zoom::YYACCEPT {} {
    return -code return 0
}

proc zoom::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc zoom::yyerror {s} {
    puts stderr $s
}

proc zoom::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc zoom::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set zoom::table {
  15:259 shift
  0:257 shift
  0:258 shift
  0:260 shift
  2:257 reduce
  5:0,target 8
  9:0 reduce
  6:259,target 11
  0:261 shift
  0:266,target 8
  2:258 reduce
  11:0 reduce
  2:259 reduce
  0:263 shift
  0:264 shift
  1:259,target 4
  4:259 reduce
  0:265 shift
  6:259 reduce
  0:266 goto
  13:259,target 12
  0:268 goto
  0:265,target 7
  6:0,target 11
  0:269 goto
  16:0,target 15
  2:0 reduce
  10:267,target 15
  1:258,target 4
  9:259,target 6
  7:262,target 11
  6:0 reduce
  0:264,target 6
  4:259,target 10
  16:259,target 15
  1:257,target 4
  17:0,target 3
  12:0 reduce
  9:258,target 2
  10:0,target 1
  9:268,target 14
  11:259,target 13
  0:263,target 5
  16:0 reduce
  12:257 shift
  10:259 reduce
  12:258 shift
  9:257,target 1
  12:259 reduce
  8:0,target 0
  7:270,target 13
  3:0 reduce
  1:0,target 4
  14:259 reduce
  11:0,target 13
  2:259,target 5
  16:259 reduce
  1:257 reduce
  14:259,target 7
  10:267 goto
  1:258 reduce
  7:258,target 2
  1:259 reduce
  7:268,target 12
  12:268 goto
  3:259 reduce
  13:0 reduce
  9:0,target 6
  0:261,target 4
  2:258,target 5
  7:257 shift
  2:0,target 5
  5:259 reduce
  12:0,target 14
  7:258 shift
  9:257 shift
  17:0 reduce
  9:258 shift
  7:257,target 1
  5:259,target 8
  9:259 reduce
  7:262 shift
  0:260,target 3
  2:257,target 5
  0:269,target 10
  4:0 reduce
  12:259,target 14
  3:0,target 9
  13:0,target 12
  7:268 goto
  8:0 accept
  7:270 goto
  10:0 reduce
  9:268 goto
  0:258,target 2
  0:268,target 9
  14:0 reduce
  12:258,target 2
  12:268,target 16
  3:259,target 9
  4:0,target 10
  14:0,target 7
  15:259,target 17
  0:257,target 1
  1:0 reduce
  11:259 reduce
  13:259 reduce
  12:257,target 1
  10:259,target 2
  5:0 reduce
}

array set zoom::rules {
  9,l 269
  11,l 269
  15,l 270
  2,l 267
  6,l 269
  12,l 269
  3,l 266
  7,l 269
  13,l 270
  0,l 271
  4,l 268
  8,l 269
  10,l 269
  14,l 270
  1,l 266
  5,l 268
}

array set zoom::rules {
  5,dc 1
  0,dc 1
  12,dc 2
  8,dc 1
  3,dc 3
  15,dc 2
  10,dc 1
  6,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 1
  11,dc 1
  7,dc 2
  2,dc 0
  14,dc 1
}

array set zoom::rules {
  13,line 37
  2,e 1
  7,line 29
  10,line 32
  4,line 24
  1,line 20
  15,line 39
  9,line 31
  12,line 34
  6,line 28
  3,line 21
  14,line 38
  8,line 30
  11,line 33
  5,line 25
  2,line 20
}

proc zoom::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt

    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)]} {
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
                yyerror "parse error"
                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    2 { zoom::yyclearin; YYACCEPT }
                    4 { set _ $1 }
                    5 { set _ $1 }
                    6 { Zoom $1 $1 }
                    7 { Zoom $1 $2 }
                    8 { PanZoomDialog }
                    9 { PanZoomDestroyDialog }
                    10 { Zoom 2 2 }
                    11 { Zoom .5 .5 }
                    13 { ZoomToFit }
                    14 { global zoom; set current(zoom) "$1 $1"; ChangeZoom }
                    15 { global zoom; set current(zoom) "$1 $2"; ChangeZoom }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc zoom::yyerror {msg} {
     puts stderr "$zoom::yy_current_buffer"
     puts stderr [format "%*s" $zoom::index_ ^]
     puts stderr "$msg:"
}
