package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval mode {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc mode::YYABORT {} {
    return -code return 1
}

proc mode::YYACCEPT {} {
    return -code return 0
}

proc mode::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc mode::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc mode::yyerror {s} {
    puts stderr $s
}

proc mode::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc mode::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set mode::table {
  0:258 shift
  0:260 shift
  0:259 shift
  2:257 reduce
  5:0,target 9
  9:0 reduce
  8:257,target 12
  0:261 shift
  0:266,target 9
  11:0 reduce
  0:262 shift
  4:257 reduce
  0:263 shift
  6:257 reduce
  0:264 shift
  3:257,target 7
  13:270 goto
  0:265 shift
  8:257 reduce
  0:266 shift
  15:257,target 16
  0:267 shift
  13:270,target 15
  0:265,target 8
  0:268 shift
  6:0,target 10
  0:269 goto
  16:0,target 3
  10:257,target 14
  0:271 goto
  2:0 reduce
  0:272 goto
  6:0 reduce
  6:257,target 10
  0:264,target 7
  7:0,target 11
  1:257,target 5
  12:0 accept
  10:0,target 14
  13:257,target 2
  0:263,target 6
  16:0 reduce
  10:257 reduce
  9:257,target 13
  14:257 reduce
  8:0,target 12
  3:0 reduce
  1:0,target 5
  11:0,target 15
  0:262,target 5
  4:257,target 8
  0:272,target 14
  7:0 reduce
  1:257 reduce
  3:257 reduce
  11:257,target 15
  5:257 reduce
  13:0 reduce
  9:0,target 13
  0:261,target 4
  7:257 reduce
  0:271,target 13
  2:0,target 6
  12:0,target 0
  9:257 reduce
  7:257,target 11
  0:259,target 2
  0:260,target 3
  2:257,target 6
  0:269,target 12
  4:0 reduce
  14:257,target 4
  3:0,target 7
  13:0,target 1
  8:0 reduce
  10:0 reduce
  0:258,target 1
  0:268,target 11
  14:0 reduce
  5:257,target 9
  4:0,target 8
  14:0,target 4
  11:257 reduce
  1:0 reduce
  13:257 reduce
  0:267,target 10
  15:257 shift
  5:0 reduce
}

array set mode::rules {
  9,l 272
  11,l 272
  15,l 272
  2,l 270
  6,l 272
  12,l 272
  3,l 269
  7,l 272
  13,l 272
  0,l 273
  4,l 271
  8,l 272
  10,l 272
  14,l 272
  1,l 269
  5,l 272
}

array set mode::rules {
  5,dc 1
  0,dc 1
  12,dc 1
  8,dc 1
  3,dc 3
  15,dc 1
  10,dc 1
  6,dc 1
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 1
  11,dc 1
  7,dc 1
  2,dc 0
  14,dc 1
}

array set mode::rules {
  13,line 41
  2,e 1
  7,line 35
  10,line 38
  4,line 30
  1,line 26
  15,line 44
  9,line 37
  12,line 40
  6,line 34
  3,line 27
  14,line 43
  8,line 36
  11,line 39
  5,line 33
  2,line 26
}

array set mode::lr1_table {
  13,trans {{270 15}}
  0 {{0 0 0} {1 0 0} {3 0 0} {4 {0 257} 0} {5 {0 257} 0} {6 {0 257} 0} {7 {0 257} 0} {8 {0 257} 0} {9 {0 257} 0} {10 {0 257} 0} {11 {0 257} 0} {12 {0 257} 0} {13 {0 257} 0} {14 {0 257} 0} {15 {0 257} 0}}
  14,trans {}
  1 {{5 {0 257} 1}}
  15,trans {{257 16}}
  2 {{6 {0 257} 1}}
  16,trans {}
  3 {{7 {0 257} 1}}
  0,trans {{258 1} {259 2} {260 3} {261 4} {262 5} {263 6} {264 7} {265 8} {266 9} {267 10} {268 11} {269 12} {271 13} {272 14}}
  4 {{8 {0 257} 1}}
  1,trans {}
  5 {{9 {0 257} 1}}
  2,trans {}
  6 {{10 {0 257} 1}}
  3,trans {}
  7 {{11 {0 257} 1}}
  4,trans {}
  8 {{12 {0 257} 1}}
  5,trans {}
  9 {{13 {0 257} 1}}
  10 {{14 {0 257} 1}}
  6,trans {}
  11 {{15 {0 257} 1}}
  7,trans {}
  12 {{0 0 1}}
  8,trans {}
  13 {{1 0 1} {3 0 1} {2 257 0}}
  10,trans {}
  9,trans {}
  14 {{4 {0 257} 1}}
  15 {{3 0 2}}
  11,trans {}
  16 {{3 0 3}}
  12,trans {}
}

array set mode::token_id_table {
  264,line 17
  270,t 1
  269,t 1
  265,title CROP
  261,line 14
  257,t 0
  270,title {}
  269,title {}
  273,line 45
  257,line 7
  262,t 0
  270,line 26
  269,line 25
  259,title REGION
  260,title CROSSHAIR
  266,t 0
  271,t 1
  error error
  264,title ROTATE
  266,line 19
  error,line 24
  268,title POINTER
  258,t 0
  263,line 16
  error,title {}
  273,title {}
  263,t 0
  259,line 12
  260,line 13
  258,title NONE
  272,line 32
  267,t 0
  263,title ZOOM
  272,t 1
  268,line 21
  267,title EXAMINE
  257 STRING_
  258 NONE_
  259,t 0
  259 REGION_
  260 CROSSHAIR_
  260,t 0
  272,title {}
  261 COLORBAR_
  265,line 18
  262 PAN_
  263 ZOOM_
  257,title string
  264 ROTATE_
  264,t 0
  265 CROP_
  262,line 15
  266 CATALOG_
  267 EXAMINE_
  0,t 0
  0 {$}
  262,title PAN
  268 POINTER_
  268,t 0
  270 @PSEUDO1
  269 command
  271 mode
  error,t 0
  272 item
  258,line 11
  273,t 1
  273 start'
  266,title CATALOG
  271,line 29
  271,title {}
  261,t 0
  267,line 20
  265,t 0
  261,title COLORBAR
}

proc mode::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    2 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    4 { ProcessCmdSet current mode $1 ChangeMode }
                    5 { set _ none }
                    6 { set _ region }
                    7 { set _ crosshair }
                    8 { set _ colorbar }
                    9 { set _ pan }
                    10 { set _ zoom }
                    11 { set _ rotate }
                    12 { set _ crop }
                    13 { set _ catalog }
                    14 { set _ examine }
                    15 { set _ region }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc mode::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
